c
exit
c
score
n
score
n
exit
score
n
exit
c
score
n
score
n
c
n
results.first(10)[(rand() * 10).to_i][:question]
results.first(10)[(rand() * 10).to_i]
n
Question.all.map {|q| q.id }.size
Question.all.map {|q| q.id }
results.size
results
n
c
Question.all.map {|q| q.id }
results.size
results
n
c
results
results.first(10)
results
c
n
s
c
params[:questions].class
params[:questions]
params
c
json = params["_json"]
c
params
c
request[:body]
request
params
c
params
c
n
c
reload!
options
c
options
c
options
c
options
c
Sport.second.answers.count
Sport.first.answers.count
Sport.first.answers.first
Sport.first.answers
Sport.first
questions.first(10)[rand() * 10
(rand() * 10).to_i
rand() * 10
rand() * 100
rand() * 10
rand()
questions.first(10)[rand()
questions.first(10)
questions
questions.first[:score]
questions.first
n
c
questions.first
n
c
reload!
questions.first
questions.reverse!
questions
questions.sort_by! {|q| q[0]}
questions.sort_by!* {|q| q[0]}
questions.sort_by {|q| q[0]}.reverse.first
questions.sort_by {|q| q[0]}.reverse
questions.sort_by {|q| q[0]}.last
questions.sort_by {|q| q[0]}.first
questions.sort_by {|q| q[0]}
questions.second
questions.first
questions.size
questions
n
c
calc_question_score(Question.first)
calc_question_scoring(Question.first)
c
service.filename
exit
question.save
question.nominal = "exterieur"
question
exit
Answer.answers[@sport.answers[i].answer]
@sport.answers[i].answer
exit
c
exit
answer
exit
params[:sport][:questions].each {|k,v| [k, v] }
params[:sport][:questions].map {|k,v| [k, v] }
params[:sport][:questions].each {|k,v| [k, v] }
params[:sport][:questions].each
params[:sport][:questions]
params
exit
@sport.answer
@sport.questions
@sport
params
